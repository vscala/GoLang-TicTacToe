/*
	TicTacToe GoLang Project
	
*/
package main

import (
	"fmt"
	"math/rand"
)

// Constants
const XTOKEN string = "X"
const OTOKEN string = "O"
var PLACEMENTBOARD = [5][5]string {{"1", "|", "2", "|", "3"}, {"-", "+", "-", "+", "-"}, {"4", "|", "5", "|", "6"}, {"-", "+", "-", "+", "-"}, {"7", "|", "8", "|", "9"}};

// Game variables
var running bool = true
var turn bool = true
var aiTurn bool = false
var aiOpponent bool = true
var moveCount int = 0
var board = [5][5]string {{" ", "|", " ", "|", " "}, {"-", "+", "-", "+", "-"}, {" ", "|", " ", "|", " "}, {"-", "+", "-", "+", "-"}, {" ", "|", " ", "|", " "}};

// Choose if X or O token
func chooseToken() {
	for true {
		fmt.Println("Choose your token type (X/O):")
		var choice string
		fmt.Scanln(&choice)
		if choice == "O" {
			aiTurn = true
			return
		} else if choice == "X" {
			aiTurn = false
			return
		}
	}
}

// Choose opponent
func chooseOpponent() {
	for true {
		fmt.Println("Do you wish to play against the computer (y/n)?")
		var choice string
		fmt.Scanln(&choice)
		if choice == "y" {
			aiOpponent = true
			chooseToken()
			return
		} else if choice == "n" {
			aiOpponent = false
			return
		}
	}
}

// Print current board state
func printBoard() {
	for i := 0; i < 5; i++ {
		for j := 0; j < 5; j++ {
			fmt.Print(board[i][j])
		}
		fmt.Println()
	}
	fmt.Println()
}

// Prints board to show placement options
func printPlacementBoard() {				   
	for i := 0; i < 5; i++ {
		for j := 0; j < 5; j++ {
			fmt.Print(PLACEMENTBOARD[i][j])
		}
		fmt.Println()
	}
	fmt.Println("These numbers represent places you can place your piece")
	fmt.Println()
}

// Returns a list of valid moves
func getValidMoves() [][]int {
	out := make([][]int, 9)
	for t := 0; t < 9; t++ {
		out[t] = make([]int, 2)
		out[t][0] = -1
		out[t][1] = -1
	}
	k := 0
	for i := 0; i < 5; i+=2 {
		for j := 0; j < 5; j+=2 {
			if board[i][j] == " " {
				out[k][0] = i
				out[k][1] = j
				k += 1
			}
		}
	}
	return out
}

// Get next move (from either player or computer)
func getMove() (row int, column int) {
	if aiOpponent && turn == aiTurn {
		row, column = getAIMove()
	} else {
		row, column = getPlayerMove()
	}
	return row, column
}

// Returns a move generated by the computer
func getAIMove() (row int, column int) {
	found := false
	validMoves := getValidMoves()
	
	for !found {
		// generate a random move
		rng := rand.Intn(10-1)+1
		switch rng {
			case 1:
				row = 0; column = 0
			case 2:
				row = 0; column = 2
			case 3:
				row = 0; column = 4
			case 4:
				row = 2; column = 0
			case 5:
				row = 2; column = 2
			case 6:
				row = 2; column = 4
			case 7:
				row = 4; column = 0
			case 8:
				row = 4; column = 2
			case 9:
				row = 4; column = 4
		}
		// check if move is in validMoves
		for k := 0; k < 9; k++ {
			if validMoves[k][0] == row && validMoves[k][1] == column {
				found = true
				break
			}
		}
		
	}
	return row, column
}

// Read user input from command line
func getPlayerMove() (row int, column int) {
	// get user placement
	var selection int
	found := false
	validMoves := getValidMoves()
	
	for !found {
		fmt.Println("Enter a number (1-9) to place your piece")
		fmt.Scanln(&selection)
		switch selection {
		case 1:
			row = 0; column = 0
		case 2:
			row = 0; column = 2
		case 3:
			row = 0; column = 4
		case 4:
			row = 2; column = 0
		case 5:
			row = 2; column = 2
		case 6:
			row = 2; column = 4
		case 7:
			row = 4; column = 0
		case 8:
			row = 4; column = 2
		case 9:
			row = 4; column = 4
		}
		// check if move is in validMoves
		for k := 0; k < 9; k++ {
			if validMoves[k][0] == row && validMoves[k][1] == column {
				found = true
				break
			}
		}
		
	}
	return row, column
}

// Play move on board, and increment moveCount
func playMove(i int, j int) {
	if turn {
		board[i][j] = XTOKEN
	} else {
		board[i][j] = OTOKEN
	}
	moveCount++
}

// Check if game has ended
func checkEnd() {
	if checkWin() {
		running = false
		if turn {
			fmt.Println("Player X won")
		} else {
			fmt.Println("Player O won")
		}
	} else if checkDraw() {
		running = false
		fmt.Println("Game drawn")
	}
}

// Determine if current board state is won
func checkWin() bool {
	for i:= 0; i < 5; i+=2 {
		// check rows
		if board[i][0] != " " && board[i][0] == board[i][2] && board[i][0] == board[i][4] {
			return true
		}
		// check columns
		if board[0][i] != " " && board[0][i] == board[2][i] && board[0][i] == board[4][i] {
			return true
		}
	}
	if board[2][2] != " " {
		// check first diagonal
		if board[2][2] == board[0][0] && board[2][2] == board[4][4] {
			return true
		}
		// check second diagonal
		if board[2][2] == board[0][4] && board[2][2] == board[4][0] {
			return true
		}
	}
	return false
}

// Determine if current board state is drawn
func checkDraw() bool {
	return moveCount == 9
}

// Determine if a new game should be played
func playAgain() {
	for true {
		fmt.Println("Do you wish to play again (y/n)?")
		var choice string
		fmt.Scanln(&choice)
		if choice == "y" {
			clearGame()
			runner()
			return
		} else if choice == "n" {
			return
		}
	}
}

// Set variables to default values and clear board
func clearGame() {
	running = true
	turn = true
	aiTurn = false
	aiOpponent = true
	moveCount = 0
	for i := 0; i < 5; i += 2 {
		for j := 0; j < 5; j += 2 {
			board[i][j] = " "
		}
	}
}

/*
	Runner:
		choose human or AI opponent
		print placement board
		Each turn:
		1a. get move from user input
		1b. generate AI move
		2. play move on board
		3. print new board
		4. determine if game is won
		5. determine if game is drawn
		6. swap turn
*/
func runner() {
	chooseOpponent()
	printPlacementBoard()
	for running {
		row, column := getMove()
		playMove(row, column)
		printBoard()
		checkEnd()
		turn = !turn
	}
	playAgain()
}

func main() {
	runner()
}
